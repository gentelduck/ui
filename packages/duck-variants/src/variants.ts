import { VariantParams, VariantsOptions } from './variants.types'

/**
 * Utility function to generate class names based on variant options.
 *
 * This function allows you to define a set of variants (like `size`, `intent`, etc.) and their associated class names.
 * You can also provide default variants and handle compound variants that depend on multiple variant values.
 *
 * @template TVariants - A record mapping variant names to variant values and their corresponding class names.
 *
 * @param base - The base string of class names that will always be applied to the element.
 * @param options - Configuration options for the variants, including:
 *   - `variants`: A mapping of variant names to their possible values and the associated class names.
 *   - `defaultVariants`: Optional default values for the variants if none are provided in `props`.
 *   - `compoundVariants`: Optional compound variants, which allow you to define classes based on multiple variant values matching specific conditions.
 *
 * @returns A function that accepts an optional `props` object, which can include:
 *   - Variant values from `TVariants`, e.g., `size: 'small'`, `intent: 'primary'`
 *   - Optional `className` or `class` fields for additional class names.
 *
 * This function returns a string of unique class names generated by combining the base class with the selected variant classes, and any additional classes from `props`.
 *
 * @example
 * ```ts
 * const button = cva("button", {
 *   variants: {
 *     intent: {
 *       primary: ["bg-blue-500", "text-white", "border-transparent", "hover:bg-blue-600"],
 *       secondary: ["bg-white", "text-gray-800", "border-gray-400", "hover:bg-gray-100"],
 *     },
 *     size: {
 *       small: ["text-sm", "py-1", "px-2"],
 *       medium: ["text-base", "py-2", "px-4"],
 *     },
 *   },
 *   compoundVariants: [
 *     { intent: "primary", size: "medium", class: "uppercase" },
 *     { intent: "secondary", size: "small", className: "italic" },
 *   ],
 *   defaultVariants: {
 *     intent: "primary",
 *     size: "medium",
 *   },
 * })
 *
 * const className = button({ intent: "secondary", size: "small", className: "extra-class" });
 * // Output: 'button bg-white text-gray-800 border-gray-400 hover:bg-gray-100 text-sm py-1 px-2 italic extra-class'
 * ```
 */
export function cva<
  TVariants extends Record<string, Record<string, string | Array<string>>>,
>(
  base: string,
  options: VariantsOptions<TVariants>,
): (
  props?: VariantParams<TVariants> & {
    className?: string | Array<string>
    class?: string | Array<string>
  },
) => string {
  const { variants, defaultVariants, compoundVariants } = options

  return (props = {}) => {
    const classSet = new Set<string>()

    // Add base classes
    for (const cls of base.split(/\s+/)) {
      classSet.add(cls)
    }

    // Track resolved variant values
    const resolvedVariants: Record<string, string | undefined> = {}

    // Apply variants with fallbacks to defaultVariants
    for (const key in variants) {
      const propValue = props[key as keyof TVariants]
      const value =
        propValue !== undefined
          ? propValue
          : defaultVariants?.[key as keyof typeof defaultVariants]

      resolvedVariants[key] = value as string

      const variantClasses = variants[key]?.[value as string]

      // If variantClasses is an array, iterate over each value
      if (Array.isArray(variantClasses)) {
        for (const cls of variantClasses) {
          classSet.add(cls)
        }
      } else if (variantClasses) {
        // If it's a single string, split into classes and add them
        for (const cls of variantClasses.split(/\s+/)) {
          classSet.add(cls)
        }
      }
    }

    // Handle compound variants as an array of objects
    if (compoundVariants?.length) {
      for (const compound of compoundVariants) {
        const {
          class: compoundClass,
          className: compoundClassName,
          ...compoundConditions
        } = compound
        const isMatch = Object.entries(compoundConditions).every(
          ([key, value]) => resolvedVariants[key] === value,
        )

        if (isMatch) {
          // Add compound class or className if conditions match
          if (compoundClass) {
            for (const cls of (compoundClass as string).split(/\s+/)) {
              classSet.add(cls)
            }
          }
          if (compoundClassName) {
            for (const cls of (compoundClassName as string).split(/\s+/)) {
              classSet.add(cls)
            }
          }
        }
      }
    }

    // Add `className` or `class` from props
    if ('className' in props && props.className) {
      for (const cls of (Array.isArray(props.className)
        ? props.className
        : [props.className]
      ).flat()) {
        classSet.add(cls)
      }
    }

    if ('class' in props && props.class) {
      for (const cls of (Array.isArray(props.class)
        ? props.class
        : [props.class]
      ).flat()) {
        classSet.add(cls)
      }
    }

    // Return the combined class names as a space-separated string
    return Array.from(classSet).join(' ')
  }
}
