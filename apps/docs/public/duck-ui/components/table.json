{
  "name": "table",
  "type": "registry:ui",
  "dependencies": [],
  "registryDependencies": [],
  "root_folder": "table",
  "files": [
    {
      "path": "table/index.ts",
      "content": "export * from './table'\nexport * from './table.hook'\nexport * from './table.lib'\nexport * from './table.constants'\nexport * from './table.types'\n",
      "type": "registry:ui",
      "target": "components/ui/index.ts"
    },
    {
      "path": "table/table-advanced.constants.tsx",
      "content": "import { ArrowDownIcon, ArrowUpIcon, EyeOff } from 'lucide-react'\nimport { TableColumnSortableType } from './table-advanced.types'\n\nexport const dropdownMenuOptions: TableColumnSortableType[] = [\n  {\n    icon: <ArrowDownIcon className=\"mr-2 text-muted-foreground/80\" />,\n    children: 'ascending',\n    variant: 'ghost',\n    size: 'sm',\n  },\n\n  {\n    icon: <ArrowUpIcon className=\"mr-2 text-muted-foreground/80\" />,\n    children: 'descending',\n    variant: 'ghost',\n    size: 'sm',\n  },\n  {\n    icon: <EyeOff className=\"mr-2 text-muted-foreground/80\" />,\n    children: 'hide' as 'other',\n    variant: 'ghost',\n    size: 'sm',\n  },\n]\n",
      "type": "registry:ui",
      "target": "components/ui/table-advanced.constants.tsx"
    },
    {
      "path": "table/table-advanced.tsx",
      "content": "import { cn } from '@gentelduck/libs/cn'\nimport { TableHead, TableHeader, TableRow } from '../table'\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuGroup,\n  DropdownMenuItem,\n  DropdownMenuSeparator,\n  DropdownMenuTrigger,\n} from '../dropdown-menu'\nimport { ArrowDownIcon, ArrowUpDown, ArrowUpIcon } from 'lucide-react'\nimport React from 'react'\nimport { Button } from '../button'\nimport { Table, TableBody } from './table'\nimport { dropdownMenuOptions } from './table-advanced.constants'\nimport {\n  DuckTableBodyProps,\n  DuckTableContextType,\n  DuckTableHeadCheckboxProps,\n  DuckTableHeadSelectableProps,\n  DuckTableHeaderProps,\n  DuckTableProps,\n  DuckTableProviderProps,\n  DuckTableRowCheckboxProps,\n  GetColumnLabel,\n  TableColumnType,\n  TableContentDataType,\n  TableSearchStateType,\n} from './table-advanced.types'\nimport { ScrollArea, ScrollBar } from '../scroll-area/'\nimport { Checkbox } from '../checkbox'\nimport { Input } from '../input'\n\nexport const DuckTableContext =\n  React.createContext<DuckTableContextType<any> | null>(null)\n\nexport function useDuckTable<TColumnName extends readonly TableColumnType[]>() {\n  const context = React.useContext<\n    DuckTableContextType<GetColumnLabel<TColumnName>>\n  >(\n    DuckTableContext as unknown as React.Context<\n      DuckTableContextType<GetColumnLabel<TColumnName>>\n    >\n  )\n  if (!context) {\n    throw new Error('useTableProvider must be used within an TableProvider')\n  }\n  return context\n}\n\nexport function DuckTableProvider<TColumnName extends string[]>({\n  table_rows,\n  table_columns,\n  children,\n  className,\n  ...props\n}: DuckTableProviderProps<TColumnName>) {\n  const [search, setSearch] = React.useState<TableSearchStateType>({\n    query: '',\n    queryBy: [],\n  })\n\n  const [tableColumns, setTableColumns] = React.useState<\n    Map<string, TableColumnType>\n  >(new Map(table_columns.map((column) => [column.label, column])))\n\n  const [selectedRows, setSelectedRows] = React.useState<\n    Set<TableContentDataType<TColumnName>>\n  >(new Set())\n\n  const DuckTable = DuckTableContext //<TColumnName>()\n\n  return (\n    <DuckTable.Provider\n      value={{\n        tableColumns,\n        setTableColumns,\n        tableRows: table_rows,\n        selectedRows,\n        setSelectedRows,\n        search,\n        setSearch,\n      }}\n    >\n      <div\n        className={cn(\n          `w-full- flex flex-col gap-4 w-[800px] h-[500px]`,\n          className\n        )}\n        {...props}\n      >\n        {children}\n      </div>\n    </DuckTable.Provider>\n  )\n}\nDuckTableProvider.displayName = 'DuckTableProvider'\n\nexport function DuckTable({\n  wrapper,\n  className,\n  children,\n  ...props\n}: DuckTableProps) {\n  const { className: wrapperClassName, ...wrapperProps } = wrapper! ?? {}\n\n  return (\n    <ScrollArea\n      className={cn(\n        'border border-border rounded-lg !overflow-visible relative',\n        wrapperClassName\n      )}\n      {...wrapperProps}\n    >\n      <Table {...props}>{children}</Table>\n      <ScrollBar orientation='horizontal' />\n    </ScrollArea>\n  )\n}\nDuckTable.displayName = 'DuckTable'\n\n// ------------------------------------------------------------------------------------------------\n\nexport function DuckTableHeader({}: DuckTableHeaderProps) {\n  const { tableColumns } = useDuckTable()\n  return (\n    <>\n      <TableHeader>\n        <TableRow>\n          {Array.from(tableColumns.values())?.map((column, idx) => {\n            const {\n              children,\n              className,\n              sortable,\n              label,\n              showLabel,\n              ...props\n            } = column\n\n            const Component = () =>\n              !sortable ? (\n                <span className='capitalize'>\n                  {(label as string) ?? children}\n                </span>\n              ) : (\n                <DuckTableHeadSelectable\n                  column={column}\n                  label={(label as string) ?? children}\n                  showLabel={showLabel}\n                />\n              )\n\n            return (\n              !column['aria-hidden'] && (\n                <React.Fragment key={idx}>\n                  <TableHead\n                    className={cn(\n                      'py-2',\n                      idx === 0 && 'justify-start ',\n                      sortable && 'px-2',\n                      className\n                    )}\n                    {...props}\n                  >\n                    {idx === 0 ? (\n                      <div className='flex items-center gap-4'>\n                        <DuckTableHeadCheckbox\n                          type='header'\n                          className={cn(sortable && 'justify-end')}\n                        />\n                        {/*NOTE: Rendering Sorting else rendering label*/}\n                        <Component />\n                      </div>\n                    ) : (\n                      <Component />\n                    )}\n                  </TableHead>\n                </React.Fragment>\n              )\n            )\n          })}\n        </TableRow>\n      </TableHeader>\n    </>\n  )\n}\nDuckTableHeader.displayName = 'TableCustomViewHeader'\n\nexport function DuckTableHeadCheckbox({\n  className,\n  ...props\n}: DuckTableHeadCheckboxProps) {\n  const { selectedRows, setSelectedRows, tableRows } = useDuckTable()\n\n  return (\n    <div\n      className={cn(\n        'flex items-center w-fit data-[state=open]:bg-accent text-xs capitalize',\n        className\n      )}\n      {...props}\n    >\n      <Checkbox\n        className='border-border'\n        onClick={() => {\n          setSelectedRows(() => {\n            if (selectedRows.size === tableRows.length) {\n              return new Set()\n            }\n            return new Set(tableRows.map((item) => item))\n          })\n        }}\n        checked={\n          selectedRows.size === tableRows.length\n            ? true\n            : selectedRows.size < tableRows.length && selectedRows.size\n            ? 'indeterminate'\n            : false\n        }\n      />\n    </div>\n  )\n}\n\nexport function DuckTableHeadSelectable<TSort extends boolean = true>({\n  column,\n  label,\n  showLabel,\n  children,\n}: DuckTableHeadSelectableProps<TSort>) {\n  const { setTableColumns } = useDuckTable()\n\n  return (\n    <div className={cn('flex items-center space-x-2')}>\n      {(dropdownMenuOptions?.length ?? 0) > 0 && (\n        <DropdownMenu>\n          <DropdownMenuTrigger asChild>\n            <Button\n              size='sm'\n              aria-label='table-column-options'\n              aria-controls='dropdown-menu'\n              name='dropdown-menu-trigger'\n              variant='ghost'\n              aria-sort={column['aria-sort']}\n              className='data-[state=open]:bg-accent [&>div]:justify-between w-full [&>div]:w-full capitalize'\n              secondIcon={\n                column['aria-sort'] === 'ascending' ? (\n                  <ArrowDownIcon className='text-muted-foreground' />\n                ) : column['aria-sort'] === 'descending' ? (\n                  <ArrowUpIcon className='text-muted-foreground' />\n                ) : (\n                  <ArrowUpDown className='text-muted-foreground' />\n                )\n              }\n              label={\n                showLabel\n                  ? {\n                      children: label.toString() + ' options',\n                      className: 'capitalize',\n                      showLabel: true,\n                      side: 'top',\n                    }\n                  : undefined\n              }\n            >\n              {(label as string) ?? children}\n            </Button>\n          </DropdownMenuTrigger>\n          <DropdownMenuContent className='w-48'>\n            <DropdownMenuGroup>\n              {dropdownMenuOptions.map((item, idx) => {\n                return (\n                  <>\n                    {idx === dropdownMenuOptions.length - 1 && (\n                      <DropdownMenuSeparator />\n                    )}\n                    <DropdownMenuItem\n                      className='p-0'\n                      key={idx}\n                      onClick={() => {\n                        setTableColumns((prev) => {\n                          const newSet = new Map(prev)\n\n                          if (item.children === ('hide' as 'other')) {\n                            newSet.set(label, {\n                              ...column,\n                              'aria-hidden': true,\n                              hidden: true,\n                            })\n                          } else {\n                            if (newSet.get(label)?.label === item.children) {\n                              newSet.set(label, {\n                                ...column,\n                                'aria-sort': 'none',\n                              })\n                            } else {\n                              newSet.set(label, {\n                                ...column,\n                                'aria-sort': item.children,\n                              })\n                            }\n                          }\n\n                          return newSet\n                        })\n                      }}\n                    >\n                      <Button\n                        {...item}\n                        className={cn(\n                          'w-full justify-start capitalize',\n                          item.className\n                        )}\n                      >\n                        {item.children}\n                      </Button>\n                    </DropdownMenuItem>\n                  </>\n                )\n              })}\n            </DropdownMenuGroup>\n          </DropdownMenuContent>\n        </DropdownMenu>\n      )}\n    </div>\n  )\n}\n\nexport function DuckTableBody({ children }: DuckTableBodyProps) {\n  return <TableBody>{children}</TableBody>\n}\n\nexport function DuckTableRowCheckbox<\n  TColumnName extends readonly TableColumnType[]\n>({ className, tableRow, ...props }: DuckTableRowCheckboxProps<TColumnName>) {\n  const { selectedRows, setSelectedRows } = useDuckTable()\n\n  return (\n    <div\n      className={cn(\n        'flex items-center w-fit data-[state=open]:bg-accent text-xs capitalize',\n        className\n      )}\n      {...props}\n    >\n      <Checkbox\n        className='border-border'\n        onClick={() => {\n          setSelectedRows(() => {\n            if (selectedRows.has(tableRow)) {\n              return new Set(\n                Array.from(selectedRows.values()).filter(\n                  (item) => item !== tableRow\n                )\n              )\n            }\n            return new Set([...selectedRows, tableRow])\n          })\n        }}\n        checked={selectedRows.has(tableRow) ? true : false}\n      />\n    </div>\n  )\n}\n\nexport interface DuckTableTopBarProps extends React.HTMLProps<HTMLDivElement> {}\n\nexport function DuckTableTopBar({\n  className,\n  children,\n  ...props\n}: DuckTableTopBarProps) {\n  return (\n    <div\n      className={cn('', className)}\n      {...props}\n    >\n      {children}\n    </div>\n  )\n}\n\nexport interface DuckTableSearchInputProps\n  extends React.HTMLProps<HTMLDivElement> {}\n\nexport function DuckTableSearchInput({\n  className,\n  ...props\n}: DuckTableSearchInputProps) {\n  return (\n    <div\n      className={cn('flex-1', className)}\n      {...props}\n    >\n      <Input placeholder='Search...' />\n    </div>\n  )\n}\n",
      "type": "registry:ui",
      "target": "components/ui/table-advanced.tsx"
    },
    {
      "path": "table/table-advanced.types.ts",
      "content": "import { Table } from './table'\nimport { ScrollArea } from '../scroll-area'\nimport React from 'react'\nimport { Button, LabelType } from '../button'\nimport { sortArray } from './table.lib'\nimport { TableBody } from './table'\n\n// ------------------------------------------------------------------------------------------------\n// NOTE:  These types are used for the `table-advanced` context.\n// ------------------------------------------------------------------------------------------------\n\nexport interface DuckTableProviderProps<TColumnName extends string[]>\n  extends React.HTMLAttributes<HTMLDivElement> {\n  table_columns: readonly TableColumnType[]\n  table_rows: TableContentDataType<TColumnName>[]\n}\n\nexport type DuckTableContextType<TColumnName extends string[]> = {\n  tableColumns: Map<string, TableColumnType>\n  setTableColumns: React.Dispatch<\n    React.SetStateAction<Map<string, TableColumnType>>\n  >\n  tableRows: TableContentDataType<TColumnName>[]\n  selectedRows: Set<TableContentDataType<TColumnName>>\n  setSelectedRows: React.Dispatch<\n    React.SetStateAction<Set<TableContentDataType<TColumnName>>>\n  >\n  search: TableSearchStateType\n  setSearch: React.Dispatch<React.SetStateAction<TableSearchStateType>>\n}\n\nexport type TableSortByStateType<TColumnName extends string[]> = {\n  label: TColumnName[number]\n  type: React.HTMLProps<HTMLDivElement>['aria-sort']\n}\n\nexport interface TableSearchStateType {\n  query: string\n  queryBy: string[]\n}\n\n// ------------------------------------------------------------------------------------------------\n// NOTE:  These types are used for the `table-advanced` Components.\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Interface for the `DuckTable` component\n */\nexport interface DuckTableProps\n  extends React.ComponentPropsWithoutRef<typeof Table> {\n  wrapper?: React.ComponentPropsWithoutRef<typeof ScrollArea>\n}\n\n/**\n * Interface for the `DuckTableHeader` component\n */\nexport interface DuckTableHeaderProps {}\n\n/**\n * Interface for the `DuckTableHeadCheckbox` component\n */\nexport interface DuckTableHeadCheckboxProps\n  extends React.HTMLProps<HTMLDivElement> {}\n\n/**\n * Interface for the `DuckTableRowCheckbox` component\n */\nexport interface DuckTableRowCheckboxProps<\n  TColumnName extends readonly TableColumnType[],\n> extends React.HTMLProps<HTMLDivElement> {\n  tableRow: TableContentDataType<GetColumnLabel<TColumnName>>\n}\n\n/**\n * Interface for the `DuckTableHeadSelectable` component\n */\nexport interface DuckTableHeadSelectableProps<TSort extends boolean = true>\n  extends React.HTMLProps<HTMLDivElement> {\n  column: TableColumnType<TSort>\n  label: string\n  showLabel?: boolean | undefined\n}\n\n/**\n * Interface for the `DuckTableBody` component\n */\nexport interface DuckTableBodyProps\n  extends React.ComponentPropsWithoutRef<typeof TableBody> {}\n\n// ------------------------------------------------------------------------------------------------\n// NOTE:  These types are used for the `table-advanced, hence i use them to get the types.\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Extracts the `label` property from an array of `TableColumnType` objects\n * and returns a tuple of string literals representing the column labels.\n *\n * ### Type Safety Guidelines:\n * 1. Ensure the `columns` array is defined as `const` to preserve type inference.\n * 2. Use `readonly TableColumnType[]` to enforce immutability and proper inference.\n *\n * #### Inferring Labels as a Union\n * - Append `[number]` to the type to extract a union of possible labels.\n * ```ts\n * type ColumnLabel = GetColumnLabel<typeof columns>[number]; // 'Name' | 'Age' | 'Email'\n * ```\n *\n * #### Defining Columns and Extracting Labels\n * ```ts\n * // Define columns as a strongly typed readonly array\n * const columns = [\n *   { label: \"Name\" },\n *   { label: \"Age\" },\n *   { label: \"Email\" }\n * ] as const satisfies readonly TableColumnType[];\n *\n * // Extract column labels as a tuple of string literals\n * type ColumnLabels = GetColumnLabel<typeof columns>; // ['Name', 'Age', 'Email']\n * ```\n */\nexport type GetColumnLabel<TColumn extends readonly TableColumnType[]> = {\n  -readonly [K in keyof TColumn]: `${TColumn[K]['label']}`\n}\n\n/**\n * Defines the column type for a table based on a dynamic set of column names.\n *\n * ### Type Safety Guidelines:\n * 1. Define the columns array as `const` to infer the most precise type.\n * 2. Ensure the type satisfies `readonly string[]` to preserve strict type checking.\n *\n * #### Inferring Column Names as a Union\n * - Append `[number]` to the type to infer a union of possible column names.\n * ```ts\n * type ColumnName = TColumnName[number]; // Infers as a union of column names\n * ```\n *\n * #### Defining Columns and Extracting Names\n * ```ts\n * // Define column names as a strongly typed readonly array\n * const columnNames = ['name', 'age', 'email'] as const;\n *\n * // Extract column names as a union type\n * type ColumnName = typeof columnNames[number]; // 'name' | 'age' | 'email'\n * ```\n *\n * #### Example Usage\n * ```ts\n * type MyTableColumns = TableContentDataType<typeof columnNames>;\n *\n * const columns: MyTableColumns = {\n *   name: { label: \"Full Name\", children: \"firstName\", icon: { name: \"user\" } },\n *   age: { label: \"Age\", icon: { name: \"calendar\" } },\n *   email: { label: \"Email Address\" }\n * };\n * ```\n */\nexport type TableContentDataType<TColumnName extends readonly string[]> = {\n  [key in TColumnName[number]]: TableColumnType & {\n    children?: TColumnName[number]\n    icon?: React.ReactNode\n  }\n}\n\n/**\n * **Utility Type: Mutable**\n * Converts all properties of a type `T` from readonly to mutable.\n *\n * @template T - The type to make mutable.\n *\n * @example\n * ```ts\n * type ReadonlyUser = { readonly name: string; readonly age: number };\n * type MutableUser = Mutable<ReadonlyUser>;\n * // Result:\n * // {\n * //   name: string;\n * //   age: number;\n * // }\n * ```\n */\nexport type Mutable<T> = {\n  -readonly [K in keyof T]: T[K]\n} & {}\n\n/**\n * **Utility Type: Immutable**\n * Converts all properties of a type `T` from mutable to readonly.\n *\n * @template T - The type to make immutable.\n *\n * @example\n * ```ts\n * type User = { name: string; age: number };\n * type ReadonlyUser = Immutable<User>;\n * // Result:\n * // {\n * //   readonly name: string;\n * //   readonly age: number;\n * // }\n * ```\n */\nexport type Immutable<T> = {\n  readonly [K in keyof T]: T[K]\n} & {}\n\n/**\n * **Utility Type: Mapped**\n * A type that directly maps all keys of a given type `T` to themselves.\n *\n * @template T - The type to map.\n *\n * @example\n * ```ts\n * type User = { name: string; age: number };\n * type MappedUser = Mapped<User>;\n * // Result (Same as User):\n * // {\n * //   name: string;\n * //   age: number;\n * // }\n * ```\n */\nexport type Mapped<T> = {\n  [K in keyof T]: T[K]\n} & {}\n\n// ------------------------------------------------------------------------------------------------\n// NOTE:  These types are used for the `table-advanced, constants.\n// ------------------------------------------------------------------------------------------------\n\nexport type TableColumnSortableType = React.ComponentPropsWithoutRef<\n  typeof Button\n> & { children: React.HTMLProps<HTMLDivElement>['aria-sort'] }\n\n// ------------------------------------------------------------------------------------------------\n\nexport interface TableColumnType<TSort extends boolean = true>\n  extends Partial<React.HTMLProps<HTMLTableCellElement>> {\n  label: string\n  sortable?: boolean\n  showLabel?: boolean\n}\n\nexport interface TableDropdownMenuOptionsType<T extends boolean> {\n  sortArray: typeof sortArray\n  setHeaders: React.Dispatch<React.SetStateAction<TableColumnType[]>>\n  headers: TableColumnType[]\n  tableData: TableContentDataType<T>[]\n  setTableData: React.Dispatch<React.SetStateAction<TableContentDataType<T>[]>>\n  data: TableContentDataType<T>[]\n  idx: number\n  column: TableColumnType\n}\n\nexport interface TableColumnType extends React.HTMLProps<HTMLTableCellElement> {\n  // TODO: bro what the fuck is this, the old code looks bloated af.\n  // FIX: make sure to sue these in the feture\n  withLabel?: Omit<LabelType, 'showCommand' | 'showLabel'>\n  withIcon?: React.ReactNode\n}\n// ------------------------------------------------------------------------------------------------\n//NOTE: not used yet.\nexport type TableDataFilteredType<T extends Record<string, unknown>> = {\n  [K in keyof T]: [K, T[K]]\n}[keyof T][]\n\nexport interface TablePaginationStateType {\n  pageSize: number\n  pageIndex: number\n}\n\nexport interface TableSelectionStateType {\n  rowSelected: Record<string, unknown>[]\n}\n\nexport type ColumnsViewedStateType<T extends Record<string, unknown>> =\n  TableColumnType<T> | null\n\nexport type OrderStateType = {\n  orderBy: string\n  orderDir: 'asc' | 'desc'\n}\n",
      "type": "registry:ui",
      "target": "components/ui/table-advanced.types.ts"
    },
    {
      "path": "table/table.constants.ts",
      "content": "export const PAGE_SIZE = 6\nexport const PAGE_INDEX = 0\n",
      "type": "registry:ui",
      "target": "components/ui/table.constants.ts"
    },
    {
      "path": "table/table.hook.tsx",
      "content": "import React from 'react'\nimport { DuckTableContextType } from './table-advanced.types'\nimport { DuckTableContext } from './table-advanced'\n\nexport const useDuckTable = <\n  Column extends Record<string, unknown> = Record<string, unknown>,\n>(): DuckTableContextType<Column> | null => {\n  const context = React.useContext(DuckTableContext)\n  if (!context) {\n    throw new Error('useTableProvider must be used within an TableProvider')\n  }\n  return context\n}\n\n// <TableRow key={idx}>\n//                  {tableDataFiltered.map(([key, value], idx) => {\n//                    const headersEntries = headers.map(\n//                      item => item.label.toString().toLowerCase() ?? item.children?.toString().toLowerCase()\n//                    )\n//                    const { className, children, withLabel, ...props } = value\n//                    const {\n//                      className: labelClassName,\n//                      children: labelChildren,\n//                      type: labelType = 'default',\n//                      ...labelProps\n//                    } = item?.[key]?.withLabel ?? {}\n//\n//                    return (\n//                      headersEntries.includes(key.toString().toLowerCase()) && (\n//                        <TableCell\n//                          key={key}\n//                          className={cn('py-2 h-[50px]', selected.includes(item) && 'bg-muted', className)}\n//                          {...props}\n//                        >\n//                          <div\n//                            className={cn(\n//                              'items-center gap-2 flex w-full',\n//                              headers?.[idx]?.className,\n//                              className,\n//                              idx === headersEntries.length - 1 && dropdownMenu && 'justify-between w-full'\n//                            )}\n//                          >\n//                            {/*NOTE: Rendering Checkbox */}\n//                            {selection && idx === 0 && (\n//                              <Checkbox\n//                                className=\"border-border\"\n//                                onClick={() =>\n//                                  setSelected(\n//                                    selected.includes(item) ? selected.filter(i => i !== item) : [...selected, item]\n//                                  )\n//                                }\n//                                checked={selected.includes(item)}\n//                              />\n//                            )}\n//\n//                            {/*NOTE: Rendering Label */}\n//                            {labelChildren && (\n//                              <Badge\n//                                variant={'outline'}\n//                                size={'sm'}\n//                                className={cn(labelType === 'default' ? '' : 'bg-red-500', labelClassName)}\n//                                {...labelProps}\n//                              >\n//                                {labelChildren}\n//                              </Badge>\n//                            )}\n//\n//                            <div className=\"flex items-center gap-2 text-ellipsis overflow-hidden whitespace-nowrap\">\n//                              {/*NOTE: Getting Icons from Filter Data */}\n//                              {filtersData?.length &&\n//                                filtersData?.map(item => {\n//                                  return item?.content?.data.map((item, idx) => {\n//                                    const { children: Icon, ...props } = item?.element?.icon ?? {}\n//                                    return item.label?.toString().toLowerCase() ===\n//                                      (children as string).toString().toLowerCase() ? (\n//                                      <span\n//                                        className=\"whitespace-nowrap\"\n//                                        key={idx}\n//                                      >\n//                                        {(Icon ? <Icon {...props} /> : '') as React.ReactNode}\n//                                      </span>\n//                                    ) : null\n//                                  })\n//                                })}\n//\n//                              {/*NOTE: Rendering the row column childrend */}\n//                              <span className=\"text-ellipsis overflow-hidden whitespace-nowrap\">{children}</span>\n//                            </div>\n//                            {/*NOTE: Dropdown Menu */}\n//                            {idx === headersEntries.length - 1 && dropdownMenu.optionsData?.length && (\n//                              <DropdownMenuView\n//                                trigger={{\n//                                  className: 'flex h-8 w-8 p-0 data-[state=open]:bg-muted',\n//                                  children: <span className=\"sr-only\">Open menu</span>,\n//                                  variant: 'ghost',\n//                                  size: 'icon',\n//                                  icon: {\n//                                    children: Ellipsis,\n//                                    className: 'h-4 w-4',\n//                                  },\n//                                }}\n//                                content={{\n//                                  align: 'end',\n//                                  options: dropdownMenu,\n//                                }}\n//                              />\n//                            )}\n//                          </div>\n//                        </TableCell>\n//                      )\n//                    )\n//                  })}\n//                </TableRow>\n//\n",
      "type": "registry:ui",
      "target": "components/ui/table.hook.tsx"
    },
    {
      "path": "table/table.lib.ts",
      "content": "import { DropdownMenuOptionsDataType } from '@/registry/default/ui/dropdown-menu'\nimport {\n  ColumnsViewedStateType,\n  TableContentDataType,\n} from './table-advanced.types'\nimport { Order, TableHeaderType } from './table.types'\n\nexport function sortArray<T>(\n  columns: TableHeaderType[],\n  array: T[],\n  key?: keyof T,\n  order: Order = 'desc',\n) {\n  const toggleSortOrder = (currentOrder: Order): Order => {\n    if (currentOrder === 'not sorted') return order\n    if (currentOrder === 'asc' && order === 'asc') return 'not sorted'\n    if (currentOrder === 'asc' && order === 'desc') return 'desc'\n    if (currentOrder === 'desc' && order === 'desc') return 'not sorted'\n    if (currentOrder === 'desc' && order === 'asc') return 'asc'\n    return 'not sorted'\n  }\n\n  const updatedColumns = columns.map((col) => {\n    if (col.label === key) {\n      return {\n        ...col,\n        currentSort: toggleSortOrder(col.currentSort ?? 'not sorted'),\n      }\n    }\n    return col\n  })\n\n  const sortedData = array.toSorted((a, b) => {\n    const valueA = key ? (a[key] as TableContentDataType).children : a\n    const valueB = key ? (b[key] as TableContentDataType).children : b\n\n    if (order === 'not sorted' || !key) return 0\n\n    if (typeof valueA === 'string' && typeof valueB === 'string') {\n      return order === 'asc'\n        ? valueA.localeCompare(valueB)\n        : valueB.localeCompare(valueA)\n    } else if (typeof valueA === 'number' && typeof valueB === 'number') {\n      return order === 'asc' ? valueA - valueB : valueB - valueA\n    } else {\n      return order === 'asc'\n        ? valueA > valueB\n          ? 1\n          : -1\n        : valueA < valueB\n          ? 1\n          : -1\n    }\n  })\n\n  return { sortedData, updatedColumns }\n}\n\nexport type OptionsDataType<T extends Record<string, unknown>> = {\n  header: ColumnsViewedStateType<T>[]\n  columnsViewed?: ColumnsViewedStateType<T>[]\n  setColumnsViewed?: React.Dispatch<\n    React.SetStateAction<ColumnsViewedStateType<T>[]>\n  >\n}\n\nexport function get_options_data<\n  T extends Record<string, unknown> = Record<string, string>,\n>({ header, columnsViewed, setColumnsViewed }: OptionsDataType<T>) {\n  return header.map((column, idx) => {\n    const {\n      children,\n      className,\n      label,\n      sortable,\n      disabled,\n      currentSort,\n      dropdownMenuOptions,\n      ...props\n    } = column ?? {}\n\n    return {\n      key: idx,\n      className: 'capitalize',\n      checked: columnsViewed?.some((headerItem) => headerItem?.label === label),\n      disabled: disabled,\n      onCheckedChange: () => {\n        setColumnsViewed?.((prevHeaders) => {\n          const exists = prevHeaders.some(\n            (headerItem) => headerItem?.label === label,\n          )\n\n          if (exists) {\n            return prevHeaders.filter(\n              (headerItem) => headerItem?.label !== label,\n            )\n          }\n\n          const originalIndex = header.findIndex(\n            (headerItem) => headerItem?.label === label,\n          )\n          const newHeaders = [...prevHeaders]\n          newHeaders.splice(originalIndex, 0, column)\n          return newHeaders.sort(\n            (a, b) =>\n              header.findIndex((headerItem) => headerItem?.label === a?.label) -\n              header.findIndex((headerItem) => headerItem?.label === b?.label),\n          )\n        })\n      },\n      children: label ?? children,\n      ...props,\n    }\n  }) as DropdownMenuOptionsDataType<T>[]\n}\n",
      "type": "registry:ui",
      "target": "components/ui/table.lib.ts"
    },
    {
      "path": "table/table.tsx",
      "content": "import * as React from 'react'\n\nimport { ScrollArea } from '../scroll-area'\nimport { PaginationCustomView } from '../pagination'\nimport { Input } from '../input'\nimport { Combobox, type ComboboxType } from '../combobox'\nimport { CommandShortcut, type CommandListGroupDataType } from '../command'\nimport { DropdownMenuView } from '../dropdown-menu'\nimport { ContextCustomView, DuckContextMenuProps } from '../context-menu'\n\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from '../tooltip'\nimport { LabelType } from '../button'\nimport { Badge } from '../badge'\nimport { useDebounceCallback } from '@gentelduck/hooks/use-debounce'\nimport { get_options_data } from './table.lib'\nimport { PAGE_INDEX, PAGE_SIZE } from './table.constants'\nimport { useDuckTable } from './table.hook'\nimport { TableHeaderType, TablePaginationType } from './table.types'\n\nimport { cn } from '@gentelduck/libs/cn'\nimport { groupArrays } from '@gentelduck/libs/group-array'\n\nimport { CirclePlus, LucideIcon } from 'lucide-react'\nimport { CaretSortIcon, MixerHorizontalIcon } from '@radix-ui/react-icons'\nimport { Separator } from '../separator'\n\n/*\n *  - This's the normal table components.\n *  It's a custom table component, you can use the dataTable Functionality down\n *  this file to make sure you get the best performance, out of this table with\n *  a more customized design.\n */\nconst Table = React.forwardRef<\n  HTMLTableElement,\n  React.HTMLAttributes<HTMLTableElement>\n>(({ className, ...props }, ref) => (\n  <div className='relative w-full overflow-auto'>\n    <table\n      ref={ref}\n      className={cn('w-full caption-bottom text-sm', className)}\n      {...props}\n    />\n  </div>\n))\nTable.displayName = 'Table'\n\nconst TableHeader = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <thead\n    ref={ref}\n    className={cn('[&_tr]:border-b', className)}\n    {...props}\n  />\n))\nTableHeader.displayName = 'TableHeader'\n\nconst TableBody = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tbody\n    ref={ref}\n    className={cn('[&_tr:last-child]:border-0', className)}\n    {...props}\n  />\n))\nTableBody.displayName = 'TableBody'\n\nconst TableFooter = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tfoot\n    ref={ref}\n    className={cn(\n      'border-t bg-muted/50 font-medium [&>tr]:last:border-b-0',\n      className\n    )}\n    {...props}\n  />\n))\nTableFooter.displayName = 'TableFooter'\n\nconst TableRow = React.forwardRef<\n  HTMLTableRowElement,\n  React.HTMLAttributes<HTMLTableRowElement>\n>(({ className, ...props }, ref) => (\n  <tr\n    ref={ref}\n    className={cn(\n      'border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted',\n      className\n    )}\n    {...props}\n  />\n))\nTableRow.displayName = 'TableRow'\n\nconst TableHead = React.forwardRef<\n  HTMLTableCellElement,\n  React.ThHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <th\n    ref={ref}\n    className={cn(\n      'h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0',\n      className\n    )}\n    {...props}\n  />\n))\nTableHead.displayName = 'TableHead'\n\nconst TableCell = React.forwardRef<\n  HTMLTableCellElement,\n  React.TdHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <td\n    ref={ref}\n    className={cn('p-4 align-middle [&:has([role=checkbox])]:pr-0', className)}\n    {...props}\n  />\n))\nTableCell.displayName = 'TableCell'\n\nconst TableCaption = React.forwardRef<\n  HTMLTableCaptionElement,\n  React.HTMLAttributes<HTMLTableCaptionElement>\n>(({ className, ...props }, ref) => (\n  <caption\n    ref={ref}\n    className={cn('mt-4 text-sm text-muted-foreground', className)}\n    {...props}\n  />\n))\nTableCaption.displayName = 'TableCaption'\n\nexport const DuckTableBar = ({\n  children,\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => {\n  return (\n    <div\n      className={cn(\n        'flex items-end lg:items-center justify-between gap-2',\n        className\n      )}\n      {...props}\n    >\n      {children}\n    </div>\n  )\n}\n\nexport interface DuckTableSearchProps extends React.HTMLProps<HTMLDivElement> {\n  input?: DuckTableSearchInputProps\n}\n\nexport const DuckTableSearch = ({\n  children,\n  className,\n  input,\n  ...props\n}: DuckTableSearchProps) => {\n  const { setSearch } = useDuckTable() ?? {}\n\n  //NOTE: Debounce search\n  const debouncedSearch = useDebounceCallback(\n    (newValue: string) => setSearch?.((_) => ({ query: newValue })),\n    500\n  )\n\n  return (\n    <div\n      className={cn('flex flex-1 items-center space-x-2', className)}\n      {...props}\n    >\n      <DuckTableSearchInput\n        {...input}\n        trigger={{\n          ...input?.trigger,\n          onChange: (event: React.ChangeEvent<HTMLInputElement>) =>\n            debouncedSearch(event.target.value),\n        }}\n      />\n    </div>\n  )\n}\n\nexport interface DuckTableSearchInputProps {\n  trigger: React.ComponentPropsWithoutRef<typeof Input>\n  label?: LabelType\n  badge?: React.ComponentPropsWithoutRef<typeof CommandShortcut>\n  keys?: string[]\n}\n\nconst DuckTableSearchInput = React.forwardRef<\n  React.ElementRef<typeof Input>,\n  DuckTableSearchInputProps\n>(({ trigger, label, badge, keys }, ref) => {\n  const {\n    children: badgeChildren = '⌃+⇧+F',\n    className: badgeClassName,\n    ...badgeProps\n  } = badge ?? {}\n  const {\n    children: labelChildren = 'Filter tasks...',\n    className: labelClassName,\n    ...labelProps\n  } = label ?? {}\n  const {\n    className: triggerClassName = 'h-8 w-[150px] lg:w-[200px]',\n    placeholder = 'Filter tasks...',\n    ...triggerProps\n  } = trigger ?? {}\n\n  //NOTE: Duck shortcut\n  const inputRef = React.useRef<HTMLInputElement>(null)\n  // useDuckShortcut(\n  //   {\n  //     keys: keys ?? ['ctrl+shift+f'],\n  //     onKeysPressed: () => {\n  //       if (inputRef.current) {\n  //         inputRef.current.focus()\n  //       }\n  //     },\n  //   },\n  //   [inputRef],\n  // )\n  //\n\n  return (\n    <div\n      className='flex flex-col'\n      ref={ref}\n    >\n      <Tooltip delayDuration={100}>\n        <TooltipTrigger>\n          <Input\n            className={cn('h-8 w-[150px] lg:w-[200px]', triggerClassName)}\n            ref={inputRef}\n            placeholder={placeholder}\n            {...triggerProps}\n          />\n        </TooltipTrigger>\n        <TooltipContent\n          className={cn(\n            'flex items-center gap-2 z-50 justify-start',\n            labelClassName\n          )}\n          {...labelProps}\n        >\n          <CommandShortcut\n            className='text-[.8rem]'\n            {...badgeProps}\n          >\n            <Badge\n              variant='secondary'\n              size='sm'\n              className='p-0 px-2'\n            >\n              {badgeChildren}\n            </Badge>\n          </CommandShortcut>\n          <p className='text-sm'>{labelChildren}</p>\n        </TooltipContent>\n      </Tooltip>\n    </div>\n  )\n})\n\nexport interface DuckTableFilterProps<\n  T extends Record<string, any> = Record<string, string>,\n  Y extends keyof Record<string, unknown> = string\n> extends React.HTMLProps<HTMLDivElement> {\n  filter: ComboboxType<Y, Extract<keyof T, string>>[]\n}\n\nexport const DuckTableFilter = <\n  T extends Record<string, any> = Record<string, string>,\n  Y extends keyof Record<string, unknown> = string\n>({\n  children,\n  filter,\n  className,\n  ...props\n}: DuckTableFilterProps<T, Y>) => {\n  const { filterBy, setFilterBy } = useDuckTable() ?? {}\n\n  return (\n    <div\n      className={cn('flex items-center gap-2', className)}\n      {...props}\n    >\n      {filter?.map((filter, idx) => {\n        const {\n          className: triggerClassName,\n          children: triggerChildren,\n          ...triggerProps\n        } = filter?.trigger ?? {}\n        return (\n          <Combobox<Y, Extract<keyof T, string>>\n            key={idx}\n            type={'listbox'}\n            title={filter?.title}\n            wrapper={filter?.wrapper}\n            trigger={{\n              icon: { children: CirclePlus },\n              children: (triggerChildren ?? 'not found') as Y,\n              size: 'sm',\n              className: cn('', triggerClassName),\n              ...triggerProps,\n            }}\n            onSelect={\n              filter?.onSelect ?? {\n                value: filterBy as Extract<keyof T, string>[],\n                setValue: setFilterBy as React.Dispatch<\n                  React.SetStateAction<Extract<keyof T, string>[]>\n                >,\n              }\n            }\n            content={{\n              ...filter?.content!,\n            }}\n          />\n        )\n      })}\n    </div>\n  )\n}\n\nexport interface DuckTableBarRightSideProps\n  extends React.HTMLProps<HTMLDivElement> {}\n\nexport const DuckTableBarRightSide = React.forwardRef<\n  HTMLDivElement,\n  DuckTableBarRightSideProps\n>(({ className, children, ...props }, ref) => {\n  return (\n    <div\n      className={cn(\n        'grid lg:flex items-center lg:justify-between gap-2',\n        className\n      )}\n      ref={ref}\n      {...props}\n    >\n      {children}\n    </div>\n  )\n})\n\nexport interface DuckTableBarLeftSideProps\n  extends React.HTMLProps<HTMLDivElement> {}\n\nexport const DuckTableBarLeftSide = React.forwardRef<\n  HTMLDivElement,\n  DuckTableBarLeftSideProps\n>(({ className, children, ...props }, ref) => {\n  return (\n    <div\n      className={cn(\n        'grid lg:flex items-center lg:justify-between gap-2',\n        className\n      )}\n      ref={ref}\n      {...props}\n    >\n      {children}\n    </div>\n  )\n})\n\nexport interface DuckTableBarActionsProps<\n  T extends Record<string, unknown>,\n  C extends boolean\n> {\n  header: TableHeaderType<T, C>[]\n}\n\nexport const TableBarViewButton = <\n  T extends Record<string, any> = Record<string, string>,\n  C extends boolean = false\n>({\n  header,\n}: DuckTableBarActionsProps<T, C>) => {\n  const { setColumnsViewed, columnsViewed } = useDuckTable<T>() ?? {}\n\n  const option_data = get_options_data<T>({\n    header,\n    columnsViewed,\n    setColumnsViewed,\n  })\n\n  return (\n    <>\n      <DropdownMenuView\n        trigger={{\n          size: 'sm',\n          icon: {\n            children: MixerHorizontalIcon as LucideIcon,\n          },\n          children: 'View',\n          label: {\n            children: 'Toggle columns',\n            showCommand: true,\n            showLabel: true,\n            side: 'top',\n          },\n          command: {\n            key: 'ctrl+shift+v',\n            label: '⌃+⇧+V',\n          },\n        }}\n        content={{\n          label: {\n            children: 'Toggle columns',\n          },\n          options: {\n            itemType: 'checkbox',\n            optionsData: option_data,\n          },\n        }}\n      />\n    </>\n  )\n}\n\nexport type TableBodyRowProps<T extends Record<string, unknown>> = {\n  row?: React.ComponentPropsWithoutRef<typeof TableRow>\n} & Partial<DuckContextMenuProps<T>>\n\nexport const DuckTableBodyRow = <C extends Record<string, unknown>>({\n  wrapper,\n  trigger,\n  content,\n  row,\n}: TableBodyRowProps<C>) => {\n  const { children, ...props } = row ?? {}\n  return (\n    <ContextCustomView\n      trigger={{\n        ...trigger,\n        children: (\n          <TableRow {...props}>{children ?? trigger?.children}</TableRow>\n        ),\n      }}\n      wrapper={wrapper}\n      content={content}\n    />\n  )\n}\n\nexport interface DuckTableFooterProps\n  extends Partial<React.ComponentPropsWithoutRef<typeof TableFooter>> {\n  columns: FooterColumnType[]\n}\nexport type FooterColumnType = Partial<\n  React.ComponentPropsWithoutRef<typeof TableCell>\n>\n\nexport const DuckTableFooter = ({\n  className,\n  columns,\n}: DuckTableFooterProps) => {\n  return (\n    <TableFooter className={cn(className)}>\n      <TableRow>\n        {columns?.map((item, idx) => {\n          const { children, ...props } = item\n          return (\n            <TableCell\n              key={idx}\n              {...props}\n            >\n              {children}\n            </TableCell>\n          )\n        })}\n      </TableRow>\n    </TableFooter>\n  )\n}\n\nexport interface DuckTableDownBarProps\n  extends React.HTMLProps<HTMLDivElement> {}\n\nexport const DuckTableDownBar = ({\n  children,\n  className,\n  ...props\n}: DuckTableDownBarProps) => {\n  return (\n    <>\n      <Separator />\n      <div\n        className={cn(\n          'grid lg:flex items-center lg:justify-between gap-4 lg::gap-0',\n          className\n        )}\n        {...props}\n      >\n        {children}\n      </div>\n    </>\n  )\n}\nexport type DuckTablePaginationProps = {}\n\nexport const DuckTablePagination = ({}: DuckTablePaginationProps) => {\n  const { pagination, setPagination } = useDuckTable() ?? {}\n  return (\n    /*NOTE: Navigation */\n    <PaginationCustomView\n      right={{\n        onClick: () => {\n          setPagination((old) => ({\n            ...old,\n            pageIndex:\n              old.pageIndex === old.pageSize - 1\n                ? old.pageSize - 1\n                : (old.pageIndex ?? 1) + 1,\n          }))\n        },\n        command: {\n          key: 'ctrl+shift+up',\n          label: '⌃+⇧+↑',\n          // action: () =>\n          //     setPaginationState({\n          //         ...paginationState,\n          //         activePage:\n          //             paginationState.activePage === resultArrays.length - 1\n          //                 ? resultArrays.length - 1\n          //                 : (paginationState.activePage ?? 1) + 1,\n          //     })\n          //     ,\n        },\n        label: {\n          showCommand: true,\n          showLabel: true,\n          side: 'top',\n          children: 'Next page',\n        },\n        // disabled: paginationState.activePage === resultArrays.length - 1,\n      }}\n      maxRight={{\n        // onClick: () => setPaginationState({ ...paginationState, activePage: resultArrays.length - 1 }),\n        // command: {\n        //     key: 'ctrl+shift+right',\n        //     label: '⌃+⇧+→',\n        //     action: () => setPaginationState({ ...paginationState, activePage: resultArrays.length - 1 }),\n        // },\n        label: {\n          showCommand: true,\n          showLabel: true,\n          side: 'top',\n          children: 'Last page',\n        },\n        // disabled: paginationState.activePage === resultArrays.length - 1,\n      }}\n      left={{\n        // onClick: () =>\n        //     setPaginationState({\n        //         ...paginationState,\n        //         activePage: paginationState.activePage === 0 ? 0 : (paginationState.activePage ?? 1) - 1,\n        //     }),\n        // command: {\n        //     key: 'ctrl+shift+down',\n        //     label: '⌃+⇧+↓',\n        //     action: () =>\n        //         setPaginationState({\n        //             ...paginationState,\n        //             activePage: paginationState.activePage === 0 ? 0 : (paginationState.activePage ?? 1) - 1,\n        //         }),\n        // },\n        label: {\n          showCommand: true,\n          showLabel: true,\n          side: 'top',\n          children: 'Previous page',\n        },\n        // disabled: paginationState.activePage === 0,\n      }}\n      maxLeft={{\n        // onClick: () => setPaginationState({ ...paginationState, activePage: 0 }),\n        // command: {\n        //     key: 'ctrl+shift+left',\n        //     label: '⌃+⇧+←',\n        //     action: () => setPaginationState({ ...paginationState, activePage: 0 }),\n        // },\n        label: {\n          showCommand: true,\n          showLabel: true,\n          side: 'top',\n          children: 'First page',\n        },\n        // disabled: paginationState.activePage === 0,\n      }}\n    />\n  )\n}\n\nconst TablePagination = <\n  C extends Record<string, unknown> = Record<string, string>,\n  Y extends keyof Record<string, unknown> = string\n>({\n  resultArrays,\n  selected,\n  paginationState,\n  paginations,\n  value,\n  tableData,\n  setPaginationState,\n  setValue,\n}: TablePaginationType<C>) => {\n  //NOTE: gen the page length data\n  const pageLengthData = paginations?.groupSize\n    ? Array.from(\n        { length: Math.ceil(tableData.length / paginations.groupSize) },\n        (_, index) => {\n          const start = index * paginations.groupSize + 1\n          const end = Math.min(\n            (index + 1) * paginations.groupSize,\n            tableData.length\n          )\n          if (start > tableData.length) return null\n          return end.toString()\n        }\n      )\n        .filter(Boolean)\n        .reduce((acc, curr) => {\n          acc.push({ label: curr!, element: { children: curr! } })\n          return acc\n        }, [] as CommandListGroupDataType[])\n    : []\n\n  return (\n    <>\n      <div className='grid lg:flex items-center lg:justify-between gap-4 lg::gap-0'>\n        <div className='flex items-center justify-between'>\n          {/*NOTE: Select Count */}\n          {paginations?.showSelectCount && (\n            <span className='flex items-center justify-center text-sm font-medium text-muted-foreground whitespace-nowrap'>\n              {selected.length} of {tableData.length} row(s) selected.\n            </span>\n          )}\n        </div>\n        <div className='flex items-center lg:justify-between lg:gap-4'>\n          {/*NOTE: Group Size */}\n          {paginations?.showGroup && (\n            <div className='flex items-center gap-2'>\n              <span className='max-2xl:hidden flex items-center justify-center text-sm font-medium text-muted-foreground whitespace-nowrap'>\n                Rows per page\n              </span>\n              <TooltipProvider>\n                <Combobox<Extract<keyof C, string>, Y>\n                  type='combobox'\n                  content={{\n                    data: (pageLengthData ??\n                      []) as CommandListGroupDataType<Y>[],\n                    showSearchInput: false,\n                    className: 'w-[5rem] h-fit',\n                  }}\n                  trigger={{\n                    command: {\n                      key: 'ctrl+shift+c',\n                      label: '⌃+⇧+C',\n                    },\n                    label: {\n                      children: 'Rows per page',\n                      showLabel: true,\n                      side: 'top',\n                      className: 'text-xs',\n                      showCommand: true,\n                    },\n                    className: 'w-[4.5rem] h-[32px] gap-0',\n                  }}\n                  onSelect={{\n                    setValue: setValue as React.Dispatch<\n                      React.SetStateAction<Y[]>\n                    >,\n                    value: value as Y[],\n                  }}\n                />\n              </TooltipProvider>\n            </div>\n          )}\n          {paginations?.showPageCount && (\n            <span className='max-lg:hidden flex items-center justify-center text-sm font-medium text-muted-foreground whitespace-nowrap'>\n              Page {paginationState.activePage + 1} of {resultArrays.length}\n            </span>\n          )}\n        </div>\n      </div>\n    </>\n  )\n}\n\nTablePagination.displayName = 'TablePagination'\n\nexport type DuckTableBodyProps<T> = {\n  data: T\n  children: (data: T) => React.ReactNode\n}\n\n//NOTE: Function to split array into chunks\nconst splitIntoChunks = <T,>(array: T[], chunkSize: number) => {\n  const chunks = []\n  for (let i = 0; i < array.length; i += chunkSize) {\n    chunks.push(array.slice(i, i + chunkSize))\n  }\n  return chunks\n}\n\nexport const DuckTableBody = <T,>({\n  data,\n  children,\n}: DuckTableBodyProps<T[]>) => {\n  const { pagination, search, filterBy } = useDuckTable() ?? {}\n  const tableDataGrouped = groupArrays<T>(\n    [pagination?.pageSize ?? PAGE_SIZE],\n    data\n  )\n  const pageIdx = pagination?.pageIndex ?? PAGE_INDEX\n\n  // NOTE: Filter the items using the search query and filter keys.\n  const filteredData = React.useMemo(() => {\n    if (!tableDataGrouped[pageIdx]?.length) return []\n\n    return tableDataGrouped[pageIdx]?.filter((item) => {\n      const itemValues = Object.values(item as Record<string, unknown>).map(\n        (value) => JSON.stringify(value).toLowerCase()\n      )\n\n      const matchesSearch = search?.query\n        ? itemValues.some((value) => value.includes(search.query.toLowerCase()))\n        : false\n\n      const matchesFilterBy = filterBy?.length\n        ? itemValues.some((value) =>\n            filterBy.some((q) => value.includes(q.toLowerCase()))\n          )\n        : false\n\n      return (\n        (!search?.query && !filterBy?.length) ||\n        matchesSearch ||\n        matchesFilterBy\n      )\n    })\n  }, [search, filterBy, tableDataGrouped, pageIdx])\n\n  // NOTE: Split the data into chunks based on the group size.\n  const resultArrays = React.useMemo(\n    () => splitIntoChunks(filteredData, pagination?.pageSize ?? PAGE_SIZE),\n    [filteredData, pagination?.pageSize]\n  )\n\n  console.log(filteredData)\n\n  return (\n    (resultArrays[pageIdx]?.length ?? 0 > 0) && (\n      <TableBody>{children(resultArrays[pageIdx] as T[])}</TableBody>\n    )\n  )\n}\n\nexport const EmptyTable = () => {\n  return (\n    <div className='w-full h-full flex items-center justify-center absolute top-1/2 left-1/2'>\n      <h6 className='text-muted-foreground text-center'> No data </h6>\n    </div>\n  )\n}\n\nexport interface DuckTableProps\n  extends React.ComponentPropsWithoutRef<typeof Table> {\n  wrapper?: React.ComponentPropsWithoutRef<typeof ScrollArea>\n}\n\n// const {children: captionChildren, className: captionClassName, ...captionProps } = caption! ?? []\n// const [selected, setSelected] = React.useState<TableContentDataType<C>[]>([])\n// const [tableData, setTableData] = React.useState<TableContentDataType<C>[]>(tableContentData)\n// const [paginationState, setPaginationState] = React.useState({\n//     activePage: pagination?.activePage ?? 0,\n//     groupSize: pagination?.groupSize ?? tableData.length,\n// })\n// const [headers, setHeaders] = React.useState<TableHeaderType<T, C>[]>(header ?? [])\n// const [search, setSearch] = React.useState<{ q: string; qBy: string[] }>({q: '', qBy: [] })\n// const [value, setValue] = React.useState<string[]>([paginationState.groupSize.toString()])\n//\n// const [filterLabels, setFilterLabels] = React.useState<{ [key: string]: number }>({})\n//\n// //NOTE: Function to split array into chunks\n// const splitIntoChunks = (array: typeof tableData, chunkSize: number) => {\n//     const chunks = []\n//     for (let i = 0; i < array.length; i += chunkSize) {\n//         chunks.push(array.slice(i, i + chunkSize))\n//     }\n//     return chunks\n// }\n//\n// const filteredData = React.useMemo(() => {\n//     //NOTE: Step 1: Filter the data based on search.q and search.qBy\n//     const data = tableData.filter(item => {\n//         return !search.qBy.length\n//             ? Object.values(item).some(value => JSON.stringify(value).toLowerCase().includes(search.q.toLowerCase()))\n//             : Object.values(item).some(value =>\n//                 search.qBy.some(q => JSON.stringify(value).toLowerCase().includes(q.toLowerCase()))\n//             )\n//     })\n//\n//     //NOTE: Step 2: Calculate label counts based on the filtered data\n//     const labelCounts: {[key: string]: number } = {}\n//     data.forEach(item => {\n//         Object.values(item).forEach(value => {\n//             filters?.forEach(filter => {\n//                 filter?.content?.data.forEach(option => {\n//                     const label = option?.label?.toString().toLowerCase()\n//                     if (\n//                         JSON.stringify(value)\n//                             .toLowerCase()\n//                             .includes(label ?? '')\n//                     ) {\n//                         labelCounts[label ?? ''] = (labelCounts[label ?? ''] || 0) + 1\n//                     }\n//                 })\n//             })\n//         })\n//     })\n//\n//     setFilterLabels(labelCounts)\n//\n//     return data\n// }, [tableData, filters, search])\n//\n// //NOTE: Step 3: Update the filters to display the count based on the filtered data\n// const updatedFilters = React.useMemo(() => {\n//     return filters?.map(filter => {\n//         return {\n//             ...filter,\n//             content: {\n//                 ...filter.content,\n//                 data: filter?.content?.data.map(option => {\n//                     const label = option?.label?.toString().toLowerCase()\n//                     return {\n//                         ...option,\n//                         element: {\n//                             ...option.element,\n//                             label: {\n//                                 ...option?.element?.label,\n//                                 children: filterLabels[label ?? ''] || 0,\n//                             },\n//                         },\n//                     }\n//                 }),\n//             },\n//         }\n//     })\n// }, [filters, filterLabels])\n//\n// //NOTE: Step 4: Split the data into chunks based on the groupSize\n// const resultArrays = splitIntoChunks(filteredData, +value)\n\n// {tableData && !!resultArrays.length && (\n//     <TableCustomBody<T, C, Y>\n//         headers={headers}\n//         resultArrays={resultArrays}\n//         paginationState={paginationState}\n//         selection={selection ?? false}\n//         selected={selected}\n//         filtersData={filters}\n//         setSelected={setSelected}\n//         dropdownMenu={dropdownMenu ?? {}}\n//         contextMenu={contextMenu ?? {}}\n//     />\n// )}\n// {footer?.columns && <TableCustomFooter {...footer} />}\n// {caption && (\n//     <div\n//         className={cn('mb-4 text-sm text-muted-foreground text-center', captionClassName)}\n//         {...captionProps}\n//     >\n//             {caption?.children}\n//         </div>\n// )}\n// {pagination && (\n//     <TablePagination<C>\n//         selected={selected}\n//         value={value}\n//         tableData={tableData}\n//         resultArrays={resultArrays}\n//         paginationState={paginationState}\n//         paginations={pagination}\n//         setValue={setValue}\n//         setPaginationState={setPaginationState}\n//     />\n// )}\n\nexport {\n  Table,\n  TableHeader,\n  TableBody,\n  TableFooter,\n  TableHead,\n  TableRow,\n  TableCell,\n  TableCaption,\n}\n",
      "type": "registry:ui",
      "target": "components/ui/table.tsx"
    },
    {
      "path": "table/table.types.ts",
      "content": "import { ScrollArea } from '@/registry/default/ui/scroll-area'\nimport { sortArray } from './table.lib'\nimport { TableCell, TableFooter, TablePaginationStateType } from './table'\nimport { ComboboxType } from '@/registry/default/ui/combobox'\nimport { ContextMenuOptionsType } from '@/registry/default/ui/context-menu'\nimport {\n  DropdownMenuOptionsDataType,\n  DropdownMenuOptionsType,\n} from '@/registry/default/ui/dropdown-menu'\nimport { IconType, LabelType } from '../button'\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nexport type Order = 'asc' | 'desc' | 'not sorted'\n\nexport interface TableDropdownMenuOptionsType<\n  T extends Record<string, any>,\n  C extends boolean,\n> {\n  sortArray: typeof sortArray\n  setHeaders: React.Dispatch<React.SetStateAction<TableHeaderType<T, C>[]>>\n  headers: TableHeaderType<T, C>[]\n  tableData: TableContentDataType<T>[]\n  setTableData: React.Dispatch<React.SetStateAction<TableContentDataType<T>[]>>\n  data: TableContentDataType<T>[]\n  idx: number\n  column: TableHeaderType<T, C>\n}\n\nexport interface TableHeaderType<C extends boolean = true>\n  extends Partial<React.HTMLProps<HTMLTableCellElement>> {\n  label: string\n  sortable?: boolean\n  showLabel?: boolean\n  currentSort?: C extends true ? 'asc' | 'desc' | 'not sorted' : never\n  // dropdownMenuOptions?: C extends true\n  //   ? DropdownMenuOptionsDataType<TableDropdownMenuOptionsType<T, C>>[]\n  //   : never\n}\n\nexport interface TableHeaderActionsProps<\n  T extends Record<string, unknown>,\n  K extends boolean,\n> {\n  header: TableHeaderType<T, K>[]\n  headers: TableHeaderType<T, K>[]\n  setHeaders: React.Dispatch<React.SetStateAction<TableHeaderType<T, K>[]>>\n}\n\n// TableHeaderOptions\nexport interface TableHeaderOptionsType<\n  T extends Record<string, any>,\n  C extends boolean,\n> {\n  sortArray: typeof sortArray\n  setHeaders: React.Dispatch<React.SetStateAction<TableHeaderType<T, C>[]>>\n  headers: TableHeaderType<T, C>[]\n  tableData: TableContentDataType<T>[]\n  setTableData: React.Dispatch<React.SetStateAction<TableContentDataType<T>[]>>\n  data: TableContentDataType<T>[]\n  idx: number\n  column: TableHeaderType<T, C>\n}\n\n// TableCustomBody\nexport interface TableCustomBodyProps<\n  T extends Record<string, unknown>,\n  Y extends keyof Record<string, unknown>,\n  C extends boolean,\n> {\n  headers: TableHeaderType<T, C>[]\n  resultArrays: TableContentDataType<T>[][]\n  paginationState: PaginationState\n  selection: boolean\n  selected: TableContentDataType<T>[]\n  setSelected: React.Dispatch<React.SetStateAction<TableContentDataType<T>[]>>\n  dropdownMenu: DropdownMenuOptionsType<TableHeaderOptionsType<T, C>>\n  contextMenu: ContextMenuOptionsType<TableHeaderOptionsType<T, C>>\n  filtersData: ComboboxType<Extract<keyof C, string>, Y>[] | undefined\n}\n\n// TableCustomFooter\n\n// TablePagination\n\nexport interface TableDataKey extends React.HTMLProps<HTMLTableCellElement> {\n  withLabel?: Omit<LabelType, 'showCommand' | 'showLabel'>\n  withIcon?: React.ReactNode\n}\nexport interface TableCaptionType\n  extends React.HTMLProps<HTMLTableCaptionElement> {}\nexport interface TablePaginationsType extends React.HTMLProps<HTMLDivElement> {\n  groupSize: number\n  activePage?: number\n  showPageCount?: boolean\n  showSelectCount?: boolean\n  showNavigation?: boolean\n  showGroup?: boolean\n}\n\nexport interface PaginationState {\n  activePage: number\n  groupSize: number\n}\n\nexport interface TablePaginationType<\n  C extends Record<string, any> = Record<string, string>,\n> {\n  selected: TableContentDataType<C>[]\n  setValue: React.Dispatch<React.SetStateAction<string[]>>\n  value: string[]\n  tableData: TableContentDataType<C>[]\n  paginations?: TablePaginationsType\n  resultArrays: TableContentDataType<C>[][]\n  paginationState: PaginationState\n  setPaginationState: React.Dispatch<React.SetStateAction<PaginationState>>\n}\n\n// TableCustomView\n",
      "type": "registry:ui",
      "target": "components/ui/table.types.ts"
    }
  ],
  "source": "/registry-ui-duckui/src/table"
}